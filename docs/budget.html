<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Budget Bot - Budget Overview</title>
  <link rel="stylesheet" href="assets/style.css"/>
  <!-- Inline styles will be removed; assuming they are in style.css -->
</head>
<body>
  <header>
    <div class="header-branding">
      <h1>Budget Bot</h1>
      <button id="theme-toggle" aria-label="Toggle theme">Toggle Theme</button>
    </div>
    <nav>
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="categories.html">Categories</a></li>
            <li><a href="deposits.html">Deposits</a></li>
            <li><a href="transactions.html">Expenses</a></li>
            <li><a href="budget.html" class="active">Budget Overview</a></li>
        </ul>
    </nav>
  </header>
  <main>
    <div class="card">
      <h2>Budget Cycle Control</h2>
      <p class="text-muted">Select a budget cycle to view its status. Click "Reload" to refresh the data.</p>
      <div class="viewModeControls">
        <label><input type="radio" name="cycleToggle" value="C1" checked> Cycle 1</label>
        <label><input type="radio" name="cycleToggle" value="C2"> Cycle 2</label>
        <button id="reloadBtn" class="btn btn-sm">Reload Data</button> <!-- Added btn-sm -->
      </div>
    </div>

    <!-- Inline style block for .viewModeControls was here, now removed -->

    <div class="card">
      <h2>Overall Financial Snapshot</h2>
      <p class="text-muted">Summary of your total deposits, expenses, and available cash across all cycles.</p>
      <div id="cashflow">
        <!-- Content generated by JS -->
      </div>
    </div>

    <div class="card">
      <h2>Category Budget Performance</h2>
      <p class="text-muted">Track spending against your budget for each category in the selected cycle. The "Reset Budget" button recalculates remaining budget from this point forward, ignoring past spending within this cycle for that category.</p>
      <ul id="catBudgetList" class="category-status-list">
        <!-- Content generated by JS, structure will be:
          <li>
            <strong>Category Name (Cycle X): $Leftover left of $Budget (Percentage%)</strong>
            <div class="progress-container">
              <div class="progress-bar" style="width: ...%"></div>
            </div>
            <button class="btn btn-sm btn-secondary reset-budget-btn" title="...">Reset Budget</button>
          </li>
        -->
      </ul>
    </div>
  </main>
  <script src="assets/theme.js"></script>
  <script type="module">
    import { db } from "./firebase.js";
    import {
      collection, getDocs, doc, updateDoc
    } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";

    let currentCycle = "C1";

    document.addEventListener("DOMContentLoaded", () => {
      const radios = document.getElementsByName("cycleToggle");
      radios.forEach(radio => {
        radio.addEventListener("change", () => {
          currentCycle = radio.value;
        });
      });
      document.getElementById("reloadBtn").addEventListener("click", loadBudget);

      loadBudget();
    });

    async function loadBudget() {
      // read which cycle is checked
      const radios = document.getElementsByName("cycleToggle");
      for (let r of radios) {
        if (r.checked) {
          currentCycle = r.value;
          break;
        }
      }

      const cashflowEl = document.getElementById("cashflow");
      const catBudgetList = document.getElementById("catBudgetList");

      try {
        // 1) sum all deposits
        const depSnap = await getDocs(collection(db, "deposits"));
        let allDeps = [];
        depSnap.forEach(docSnap => {
          allDeps.push({ ...docSnap.data() });
        });
        let totalDeposits = allDeps.reduce((sum, d) => sum + (d.amount||0), 0);

        // 2) gather expense transactions
        const txnSnap = await getDocs(collection(db, "transactions"));
        let allTxns = [];
        txnSnap.forEach(docSnap => {
          allTxns.push({ ...docSnap.data() });
        });
        // filter expense or rent_expense or utility_bill (align with transaction types)
        const expenseTxns = allTxns.filter(t => t.type==="expense" || t.type==="rent_expense" || t.type === "utility_bill");
        let totalExpenses = expenseTxns.reduce((sum,e)=> sum+(e.amount||0), 0);

        let overallCash = totalDeposits - totalExpenses;

        // 3) fetch categories
        const catSnap = await getDocs(collection(db, "categories"));
        let categories = [];
        catSnap.forEach(docSnap => {
          categories.push({ id: docSnap.id, ...docSnap.data() });
        });

        // 4) build a spent map for cycle1 and cycle2
        let spentC1 = {};
        let spentC2 = {};
        expenseTxns.forEach(txn => {
          let cId= txn.categoryId;
          let cyc= txn.cycle||"C1";
          if (cyc==="C1") {
            if (!spentC1[cId]) spentC1[cId]=0;
            spentC1[cId]+= txn.amount;
          } else {
            if (!spentC2[cId]) spentC2[cId]=0;
            spentC2[cId]+= txn.amount;
          }
        });

        // For the top-level leftover sum in the selected cycle
        let totalAlloc=0;    // sum of all categories' budget for that cycle
        let totalLeft=0;     // sum of leftover across all categories

        // 5) compute leftover for each category in the selected cycle
        catBudgetList.innerHTML="";
        categories.forEach(cat => {
          if (!cat.spentReset1) cat.spentReset1=0;
          if (!cat.spentReset2) cat.spentReset2=0;

          let c1Budget= cat.cycle1||0;
          let c2Budget= cat.cycle2||0;
          let c1Spent= spentC1[cat.id]||0;
          let c2Spent= spentC2[cat.id]||0;

          let leftover=0, budgetVal=0, displayLeft=0, spentReset=0;
          let label="";

          if (currentCycle==="C1") {
            budgetVal= c1Budget;
            spentReset= cat.spentReset1||0;
            leftover = budgetVal - (c1Spent - spentReset);
            label = `(Cycle 1)`;
          } else {
            budgetVal= c2Budget;
            spentReset= cat.spentReset2||0;
            leftover = budgetVal - (c2Spent - spentReset);
            label = `(Cycle 2)`;
          }

          // leftover can be negative if overspent
          displayLeft = leftover<0 ? 0 : leftover; // for bar display
          totalAlloc += budgetVal;      // add to total cycle budget
          if (leftover>0) totalLeft+= leftover; // sum leftover, ignoring negative

          let pct=0;
          if (budgetVal>0) {
            pct= (displayLeft/budgetVal)*100;
          }

          // create the list item
          const li = document.createElement("li");
          li.innerHTML=`
            <strong>${cat.name} ${label}: $${displayLeft.toFixed(2)} left of $${budgetVal.toFixed(2)} (${pct.toFixed(1)}%)</strong>
            <div class="progress-container">
              <div class="progress-bar" style="width:${pct}%;"></div>
            </div>
          `;

          // add reset button
          const resetBtn = document.createElement("button");
          resetBtn.textContent = "Reset Budget";
          resetBtn.className = "btn btn-sm btn-secondary reset-budget-btn"; // Added classes
          resetBtn.title = `Mark all current ${currentCycle} spending for '${cat.name}' as accounted for. Future spending in this cycle will count against the full budget amount.`;
          resetBtn.onclick= async () => {
            const confirmMessage = `Are you sure you want to reset the budget tracking for '${cat.name}' in ${currentCycle}?\n\nThis means all spending so far in this cycle for this category will be considered 'accounted for', and the remaining budget will be calculated as if starting fresh from now, but only for display on this page. This does not delete any transactions.`;
            if (confirm(confirmMessage)) {
              // we only reset the spentReset for the chosen cycle
              if (currentCycle==="C1") {
                const totalSpent = c1Spent; // total spent for cycle1
                await updateDoc(doc(db,"categories", cat.id), {
                  spentReset1: totalSpent
                });
              } else {
                const totalSpent= c2Spent; // total spent for cycle2
                await updateDoc(doc(db,"categories", cat.id), {
                  spentReset2: totalSpent
                });
              }
              loadBudget();
            }
          };
          li.appendChild(resetBtn);

          catBudgetList.appendChild(li);
        });

        // 6) display overall info in the “cashflow” area
        // totalAlloc is how much was allocated across all categories for the selected cycle
        // totalLeft is how much leftover across all categories (clamped ignoring negative)
        let cyclePct=0;
        if (totalAlloc>0) cyclePct= (totalLeft/ totalAlloc)*100;

        cashflowEl.innerHTML=`
          <p><strong>Total Deposits:</strong> $${totalDeposits.toFixed(2)}</p>
          <p><strong>Total Expenses:</strong> $${totalExpenses.toFixed(2)}</p>
          <p><strong style="font-size:1.1em;">Available Cash: $${overallCash.toFixed(2)}</strong></p>
          <hr class="mt-2 mb-2">
          <h3>Budget Status for Cycle: ${currentCycle}</h3>
          <p><strong>Total Allocated for ${currentCycle}:</strong> $${totalAlloc.toFixed(2)}</p>
          <p><strong>Total Remaining (Positive Budgets Only) for ${currentCycle}:</strong> $${totalLeft.toFixed(2)}</p>
          <div class="progress-container mt-1">
            <div class="progress-bar" style="width:${cyclePct.toFixed(1)}%;" role="progressbar" aria-valuenow="${cyclePct.toFixed(1)}" aria-valuemin="0" aria-valuemax="100">${cyclePct.toFixed(1)}% of Budget Remaining</div>
          </div>
        `;

      } catch(err) {
        console.error("Error loading budget data:", err);
        cashflowEl.innerHTML = "<p class='text-danger'>Could not load cashflow data.</p>";
        catBudgetList.innerHTML= `<li class='text-danger'>Error loading category budgets: ${err.message}</li>`;
      }
    }
  </script>
</body>
</html>